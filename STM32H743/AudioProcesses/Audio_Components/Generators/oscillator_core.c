/* 
 * This program is free software: you can redistribute it and/or modify  
 * it under the terms of the GNU General Public License as published by  
 * the Free Software Foundation, version 3.
 *
 * This program is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * Project : bb1xx_743_00 
*/
/*
 * oscillator_core.c
 *
 *  Created on: Jan 8, 2024
 *      Author: fil
 */

int16_t sinetab[AUDIO_BUF_SIZE] =
{
	0x0,0x5,0x14,0x2c,0x4f,0x7b,0xb1,0xf1,
	0x13b,0x18e,0x1eb,0x251,0x2c1,0x33b,0x3be,0x44a,
	0x4df,0x57e,0x625,0x6d5,0x78f,0x850,0x91b,0x9ee,
	0xac9,0xbad,0xc98,0xd8c,0xe87,0xf8a,0x1094,0x11a6,
	0x12bf,0x13de,0x1505,0x1632,0x1766,0x18a0,0x19e0,0x1b26,
	0x1c71,0x1dc2,0x1f19,0x2074,0x21d4,0x2339,0x24a3,0x2610,
	0x2782,0x28f7,0x2a70,0x2bec,0x2d6c,0x2eee,0x3073,0x31fa,
	0x3383,0x350f,0x369c,0x382a,0x39ba,0x3b4a,0x3cdc,0x3e6d,
	0x4000,0x4192,0x4323,0x44b5,0x4645,0x47d5,0x4963,0x4af0,
	0x4c7c,0x4e05,0x4f8c,0x5111,0x5293,0x5413,0x558f,0x5708,
	0x587d,0x59ef,0x5b5c,0x5cc6,0x5e2b,0x5f8b,0x60e6,0x623d,
	0x638e,0x64d9,0x661f,0x675f,0x6899,0x69cd,0x6afa,0x6c21,
	0x6d40,0x6e59,0x6f6b,0x7075,0x7178,0x7273,0x7367,0x7452,
	0x7536,0x7611,0x76e4,0x77af,0x7870,0x792a,0x79da,0x7a81,
	0x7b20,0x7bb5,0x7c41,0x7cc4,0x7d3e,0x7dae,0x7e14,0x7e71,
	0x7ec4,0x7f0e,0x7f4e,0x7f84,0x7fb0,0x7fd3,0x7feb,0x7ffa,
	0x7fff,0x7ffa,0x7feb,0x7fd3,0x7fb0,0x7f84,0x7f4e,0x7f0e,
	0x7ec4,0x7e71,0x7e14,0x7dae,0x7d3e,0x7cc4,0x7c41,0x7bb5,
	0x7b20,0x7a81,0x79da,0x792a,0x7870,0x77af,0x76e4,0x7611,
	0x7536,0x7452,0x7367,0x7273,0x7178,0x7075,0x6f6b,0x6e59,
	0x6d40,0x6c21,0x6afa,0x69cd,0x6899,0x675f,0x661f,0x64d9,
	0x638e,0x623d,0x60e6,0x5f8b,0x5e2b,0x5cc6,0x5b5c,0x59ef,
	0x587d,0x5708,0x558f,0x5413,0x5293,0x5111,0x4f8c,0x4e05,
	0x4c7c,0x4af0,0x4963,0x47d5,0x4645,0x44b5,0x4323,0x4192,
	0x4000,0x3e6d,0x3cdc,0x3b4a,0x39ba,0x382a,0x369c,0x350f,
	0x3383,0x31fa,0x3073,0x2eee,0x2d6c,0x2bec,0x2a70,0x28f7,
	0x2782,0x2610,0x24a3,0x2339,0x21d4,0x2074,0x1f19,0x1dc2,
	0x1c71,0x1b26,0x19e0,0x18a0,0x1766,0x1632,0x1505,0x13de,
	0x12bf,0x11a6,0x1094,0xf8a,0xe87,0xd8c,0xc98,0xbad,
	0xac9,0x9ee,0x91b,0x850,0x78f,0x6d5,0x625,0x57e,
	0x4df,0x44a,0x3be,0x33b,0x2c1,0x251,0x1eb,0x18e,
	0x13b,0xf1,0xb1,0x7b,0x4f,0x2c,0x14,0x5,
};

void RunOscillator32(void)
{
uint16_t	i;
uint8_t		angle,osc_number;
uint16_t	adsr_value;

	for ( i=0;i<HALF_NUMBER_OF_AUDIO_SAMPLES;i++)
		osc_buffer[i] = 0;
	for(osc_number=0;osc_number<NUMOSCILLATORS;osc_number++)
	{
		if ( Oscillator[osc_number].state != OSC_OFF )
		{
			for ( i=0;i<HALF_NUMBER_OF_AUDIO_SAMPLES;i++)
			{
				angle = (uint8_t )(Oscillator[osc_number].current_phase >> 8);
				adsr_value = f_adsr(osc_number,angle );
				switch(Oscillator[osc_number].waveform)
				{
				case	TRIANGLE	:	osc_buffer_gen[i] = (tritab[osc_number & 0x03][angle] * adsr_value ); break;
				case	SQUARE		:
					if ( angle >  (uint8_t )((float )Oscillator[osc_number & 0x03].duty) )
						osc_buffer_gen[i] = ((DAC_RESOLUTION-1) * adsr_value );
					else
						osc_buffer_gen[i] = 0;
					break;
				case NOISE			:	osc_buffer_gen[i] = noise_buffer_gen[i] << 16 | noise_buffer_gen[(i+1) & (HALF_NUMBER_OF_AUDIO_SAMPLES-1)];break;
				default				:	osc_buffer_gen[i] = (sinetab[angle] * adsr_value ); break;
				}

				osc_buffer[i] += ((float )osc_buffer_gen[i] * Oscillator[osc_number].volume);

				Oscillator[osc_number].current_phase += Oscillator[osc_number].delta_phase;

				if ( Oscillator[osc_number].midi_note != INVALID_MIDI_NOTE)
				{
					if (( SystemFlags.oscillator_flags & OSC_TUNE_PENDING ) == OSC_TUNE_PENDING)
					{
						float	delta_phase;
						float	freq;

						freq = midi_freq[Oscillator[osc_number].midi_note] + Oscillator[osc_number].detune + SystemFlags.tuner_delta_multiplier;
						delta_phase = (float )WAVETABLE_SIZE / ((float )SystemParameters.audio_sampling_frequency / freq);
						Oscillator[osc_number].delta_phase = (uint16_t )(delta_phase * (float )INT_PRECISION);
					}
				}
			}
		}
	}
	SystemFlags.oscillator_flags &= ~OSC_TUNE_PENDING;
	for ( i=0;i<HALF_NUMBER_OF_AUDIO_SAMPLES;i++)
		oscout_buffer[i] = HALF_DAC_RESOLUTION + ((osc_buffer[i] >> 19) & (DAC_RESOLUTION-1));
}

